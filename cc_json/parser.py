# parser.py - Parses the tokens generated by the lexer and constructs the JSON data structure


class Parser:
    def __init__(self):
        """
        Initializes the Parser with attributes for managing tokens and parsing process.
        """
        self.tokens = []
        self.curr_token = None
        self.current_index = 0

    def parse(self, tokens):
        """
        Parses a list of tokens to construct the JSON data structure.

        Args:
            tokens (list): A list of tokens generated by the lexer.

        Returns:
            dict or list: The parsed JSON data structure.
        """
        print("Entering parse")
        self.tokens = tokens
        print("Tokens in parse method is: ", self.tokens)
        self.current_index = 0
        self.curr_token = self.tokens[self.current_index]
        print("Current token type before calling parse_object:", self.curr_token.type)
        return self.parse_json()

    def consume_token(self):
        """
        Advances the current token index and updates the current token.
        """
        print("Entering consume_token")
        self.current_index += 1
        print("Current index is: ", self.current_index)

        if self.current_index < len(self.tokens):
            print("Current index is: ", self.current_index)
            print("The length of the token is: ", len(self.tokens))
            self.curr_token = self.tokens[self.current_index]
            print("Current token is: ", self.curr_token.type)

    # This method ensures that the current token matches the expected types before proceeding with parsing.
    def expect_token(self, expected_type):
        """
        Checks if the current token matches the expected type and advances the token index.

        Args:
            expected_type (str): The expected token type.

        Raises:
            ValueError: If the current token type doesn't match the expected type.
        """
        print("Entering expect_token")
        if self.curr_token and self.curr_token.type == expected_type:
            self.consume_token()
        else:
            raise ValueError(f"Expected token of type '{expected_type}' but got '{self.curr_token.type}'")

        # This is the entry point for the JSON Parsing.

    def parse_json(self):
        """
        Parses the input JSON data structure based on the current token type.

        Returns:
            dict, list, str, int, float, bool, None: The parsed JSON data structure based on the token type.

        Raises:
            ValueError: If an unexpected token type is encountered or if there are no tokens to parse.
        """
        print("Entering parse_json")
        while self.curr_token and self.curr_token.type == "WHITESPACE":
            self.handle_whitespace()  # Handle whitespace at the beginning
            self.consume_token()  # Consume whitespace token

        if self.curr_token:
            token_type = self.curr_token.type
            print("Parsed token type:", token_type)

            # Handle whitespace at the beginning
            while token_type == "WHITESPACE":
                self.consume_token()
                if self.curr_token:
                    token_type = self.curr_token.type
                    print("Parsed token type:", token_type)
                else:
                    break

            if token_type == "OPEN_BRACE":
                print("Matched Open brace in parse_json")
                return self.parse_object()
            elif token_type == "OPEN_BRACKET":
                return self.parse_array()
            elif token_type == "QUOTED_STRING":
                return self.parse_string()
            elif token_type == "NUMBER":
                return self.parse_number()
            elif token_type == "TRUE" or token_type == "FALSE":
                return self.parse_boolean()
            elif token_type == "NULL":
                return self.parse_null()
            else:
                raise ValueError(f"Unexpected token type: {token_type}")
        else:
            raise ValueError("Invalid: No tokens to parse")

    # Implement methods for parsing object, array, string, number, boolean, and null
    def parse_object(self):
        """
        Parses a JSON object.

        Returns:
            dict: The parsed JSON object.
        """
        print("Entering parse_object")

        if self.curr_token.type == "OPEN_BRACE":
            print("Matched OPEN_BRACE")
            self.consume_token()

            obj = {}

            # Check for empty object
            if self.curr_token.type == "CLOSE_BRACE":
                print("Matched CLOSE_BRACE")
                self.consume_token()
                return obj

            if self.curr_token.type == "WHITESPACE":
                self.handle_whitespace()  # Skip over whitespace tokens

            while self.curr_token and self.curr_token.type != "CLOSE_BRACE":
                key = self.parse_string()  # Parse the key (string)

                self.expect_token("COLON")  # Expect a colon after the key
                value = self.parse_json()  # Parse the value (any JSON type)

                obj[key] = value

                if self.curr_token and self.curr_token.type == "COMMA":
                    self.consume_token()  # Consume the comma between key-value pairs
                    self.handle_whitespace()  # Handle whitespace after comma
                elif self.curr_token and self.curr_token.type == "WHITESPACE":
                    self.handle_whitespace()  # Skip over whitespace tokens
                elif self.curr_token and self.curr_token.type != "CLOSE_BRACE":
                    print("Invalid: Expected a comma or closing brace after value")

            # Check for trailing comma after the last key-value pair
            if self.curr_token and self.curr_token.type == "COMMA":
                raise ValueError("Invalid JSON: Trailing comma in object")

            print("Before expecting CLOSE_BRACE:", self.curr_token.type)
            self.expect_token("CLOSE_BRACE")  # Expect a closing brace '}'
            self.handle_whitespace()
            print("After expecting CLOSE_BRACE:", self.curr_token.type)
            return obj
        else:
            raise ValueError("Expected an opening brace or closing brace but got " + self.curr_token.type)

    def handle_whitespace(self):
        """
        Parses a whitespace.
        """
        print("Getting into whitespace")
        # Skip over whitespace tokens
        while self.curr_token.type == "WHITESPACE":
            self.consume_token()

    def parse_string(self):
        """
        Parses a JSON string.

        Returns:
            str: The parsed JSON string.
        """
        print("Entering parse_string with: ", self.curr_token.type)
        if self.curr_token.type == "QUOTED_STRING":
            value = self.curr_token.value[1:-1]  # Remove the surrounding quotes
            print("This is the string value without quotes 1 : ", value)
            # Handle escape sequences within the string
            value = self.handle_escape_sequences(value)
            print("This is the string value without quotes 2 : ", value)
            self.consume_token()  # Consume the string token
            print(f"String value after consuming: {value}")
            if self.curr_token and self.curr_token.type == "WHITESPACE":
                self.handle_whitespace()  # Skip over whitespace tokens
            return value
        else:
            raise ValueError("Expected a quoted string but got " + self.curr_token.type)

    @staticmethod
    def handle_escape_sequences(value):
        """
        Handles escape sequences within a JSON string.

        Args:
            value (str): The string containing escape sequences.

        Returns:
            str: The string with escape sequences replaced by corresponding characters.
        """
        print("Entering handle_escape_sequences")
        # Define a dictionary to map escape sequences to their respective characters
        escape_sequences = {
            r'\\"': '"',  # double quotation mark U+0022
            r"\\'": "'",  # single quotation mark
            r'\\n': '\n',  # line feed             U+000A
            r'\\r': '\r',  # carriage return       U+000D
            r'\\t': '\t',  # tab                   U+0009
            r'\\b': '\b',  # backspace             U+0008
            r'\\f': '\f',  # form feed             U+000C
            r'\\/': '/',  # solidus               U+002F
            r"\\\\": '\\',  # reverse solidus       U+005C
            r'\\u': 'u',
            r'\s+': '+'
        }

        # Replace escape sequences with their corresponding characters
        for escape_seq, char in escape_sequences.items():
            value = value.replace(escape_seq, char)

        return value

    def parse_array(self):
        """
        Parses a JSON array.

        Returns:
            list: The parsed JSON array.
        """
        print("Entering parse_array")

        arr = []
        if self.curr_token.type == "OPEN_BRACKET":
            self.consume_token()

            while self.curr_token and self.curr_token.type != "CLOSE_BRACKET":
                value = self.parse_json()
                self.expect_token("COMMA")
                arr.append(value)

                if self.curr_token and self.curr_token.type == "COMMA":
                    self.consume_token()
                elif self.curr_token and self.curr_token.type != "CLOSE_BRACKET":
                    raise ValueError("Expected a comma or closing bracket after value")
            self.expect_token("CLOSE_BRACKET")
            return arr
        else:
            raise ValueError("Expected an opening bracket but got " + self.curr_token.type)

    def parse_number(self):
        """
        Parses a JSON number.

        Returns:
            str: The parsed JSON number.
        """
        print("Entering parse_number")

        if self.curr_token.type == "NUMBER":
            number = self.curr_token.value
            self.consume_token()
            return number
        else:
            raise ValueError("Expected a number but got " + self.curr_token.type)

    def parse_boolean(self):
        """
        Parses a JSON boolean value.
        """

        print("Entering parse_boolean")
        if self.curr_token.type == "TRUE":
            self.consume_token()
        elif self.curr_token.type == "FALSE":
            self.consume_token()

    def parse_null(self):
        """
        Parses a JSON null value.
        """
        print("Entering parse_null")
        if self.curr_token.type == "NULL":
            self.consume_token()
